<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VANGUARD | AAA WARZONE</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Rajdhani:wght@600&display=swap" rel="stylesheet">
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; font-family: 'Rajdhani', sans-serif; }
        canvas { display: block; position: fixed; top: 0; left: 0; z-index: 1; }
        
        /* AAA Screen Overlay */
        #vignette { position: fixed; width: 100%; height: 100%; box-shadow: inset 0 0 150px rgba(0,0,0,0.8); pointer-events: none; z-index: 10; }
        
        #ui-layer { position: absolute; z-index: 100; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; transition: 0.8s ease; }
        .lobby-card { background: #0a0a0a; padding: 60px; border-left: 5px solid #00ffcc; text-align: center; }
        
        #hud { position: absolute; bottom: 40px; left: 40px; z-index: 50; display: none; color: #fff; text-shadow: 2px 2px 4px #000; }
        .hp-container { width: 300px; height: 12px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); margin-top: 8px; position: relative; }
        #hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #00ffcc, #008877); box-shadow: 0 0 15px #00ffcc; transition: width 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28); }

        #crosshair { position: fixed; top: 50%; left: 50%; width: 24px; height: 24px; border: 1px solid rgba(0,255,204,0.5); border-radius: 50%; transform: translate(-50%, -50%); z-index: 50; display: none; }
        #crosshair::before { content: ''; position: absolute; top: 50%; left: 50%; width: 2px; height: 2px; background: #00ffcc; transform: translate(-50%, -50%); }

        .btn-deploy { background: transparent; border: 2px solid #00ffcc; color: #00ffcc; padding: 18px 80px; font-size: 1.6rem; cursor: pointer; font-family: 'Orbitron'; transition: 0.3s; }
        .btn-deploy:hover { background: #00ffcc; color: #000; box-shadow: 0 0 30px #00ffcc; }
    </style>
</head>
<body>

    <div id="vignette"></div>
    <div id="crosshair"></div>
    
    <div id="hud">
        <div style="letter-spacing: 5px; font-weight: bold;">OPERATOR HEALTH</div>
        <div class="hp-container"><div id="hp-fill"></div></div>
    </div>

    <div id="ui-layer">
        <div class="lobby-card">
            <h1 style="color:#fff; font-family:Orbitron; font-size: 4rem; margin-bottom: 0;">VANGUARD</h1>
            <p style="color:#666; letter-spacing: 10px; margin-bottom: 40px;">BATTLEFIELD 2026</p>
            <button class="btn-deploy" id="play-button">INITIATE DEPLOYMENT</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>

    <script>
        let scene, camera, renderer, gun, clock;
        let isPlaying = false, health = 100;
        
        // Physics Vars
        let velocity = new THREE.Vector3();
        let canJump = false;
        const GRAVITY = 30.0;
        const JUMP_FORCE = 12.0;

        let bullets = [], enemyBullets = [], enemies = [], collidables = [];
        const keys = {};

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.01);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.rotation.order = 'YXZ';
            camera.position.y = 2;

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();

            // HDR Lighting
            const sun = new THREE.DirectionalLight(0xffffff, 2.5);
            sun.position.set(100, 200, 100);
            sun.castShadow = true;
            sun.shadow.camera.left = -200; sun.shadow.camera.right = 200;
            sun.shadow.camera.top = 200; sun.shadow.camera.bottom = -200;
            sun.shadow.mapSize.width = 4096; sun.shadow.mapSize.height = 4096;
            scene.add(sun);
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));

            createMap();
            createGun();

            document.getElementById('play-button').onclick = () => document.body.requestPointerLock();
            document.addEventListener('pointerlockchange', () => {
                isPlaying = document.pointerLockElement === document.body;
                document.getElementById('ui-layer').style.opacity = isPlaying ? '0' : '1';
                setTimeout(() => document.getElementById('ui-layer').style.display = isPlaying ? 'none' : 'flex', 500);
                document.getElementById('hud').style.display = isPlaying ? 'block' : 'none';
                document.getElementById('crosshair').style.display = isPlaying ? 'block' : 'none';
            });

            window.onkeydown = (e) => keys[e.code] = true;
            window.onkeyup = (e) => keys[e.code] = false;
            window.onmousemove = (e) => {
                if(isPlaying) {
                    camera.rotation.y -= e.movementX * 0.0015;
                    camera.rotation.x -= e.movementY * 0.0015;
                    camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
                }
            };
            window.onmousedown = () => { if(isPlaying) shoot(); };

            animate();
        }

        function createGun() {
            gun = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.18, 0.9), new THREE.MeshStandardMaterial({color: 0x050505, roughness: 0.2}));
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.7), new THREE.MeshStandardMaterial({color: 0x000000}));
            barrel.rotation.x = Math.PI/2; barrel.position.z = -0.55;
            gun.add(body, barrel);
            gun.position.set(0.35, -0.3, -0.6);
            camera.add(gun);
            scene.add(camera);
        }

        function createHumanoidAI(x, z) {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({color: 0x222222});
            
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.3), mat);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), new THREE.MeshStandardMaterial({color: 0x111111}));
            head.position.y = 0.6;
            const lLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), mat);
            lLeg.position.set(-0.2, -0.8, 0);
            const rLeg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), mat);
            rLeg.position.set(0.2, -0.8, 0);
            
            group.add(torso, head, lLeg, rLeg);
            group.position.set(x, 1.6, z);
            group.castShadow = true;
            scene.add(group);
            return group;
        }

        function createMap() {
            // High-Resolution Ground
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshStandardMaterial({color: 0x3d443a, roughness: 1}));
            ground.rotation.x = -Math.PI/2; ground.receiveShadow = true;
            scene.add(ground);

            // House Interior Fix
            const house = new THREE.Group();
            const wallMat = new THREE.MeshStandardMaterial({color: 0x444444});
            const buildWall = (w, h, d, x, y, z) => {
                const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), wallMat);
                m.position.set(x, y, z); house.add(m); collidables.push(m);
            };
            buildWall(12, 8, 0.5, 0, 4, -6); buildWall(0.5, 8, 12, -6, 4, 0); 
            buildWall(0.5, 8, 12, 6, 4, 0); buildWall(4, 8, 0.5, -4, 4, 6); buildWall(4, 8, 0.5, 4, 4, 6);
            
            const roof = new THREE.Mesh(new THREE.BoxGeometry(13, 1, 13), new THREE.MeshStandardMaterial({color: 0x1a1a1a}));
            roof.position.y = 8; house.add(roof); collidables.push(roof);
            scene.add(house); house.position.set(0,0,-30);

            // Trees & Mountains
            for(let i=0; i<60; i++) {
                const x = Math.random()*200-100, z = Math.random()*200-100;
                if(Math.abs(x) < 20 && Math.abs(z+30) < 20) continue;
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.7, 10), new THREE.MeshStandardMaterial({color: 0x2b1d0e}));
                trunk.position.set(x, 5, z); trunk.castShadow = true;
                const leaves = new THREE.Mesh(new THREE.SphereGeometry(4, 8, 8), new THREE.MeshStandardMaterial({color: 0x1e2d1a}));
                leaves.position.set(x, 11, z);
                scene.add(trunk, leaves); collidables.push(trunk);
            }

            // Create Humanoid Enemies
            for(let i=0; i<12; i++) {
                const model = createHumanoidAI(Math.random()*150-75, Math.random()*150-75);
                enemies.push({mesh: model, lastShot: 0});
            }
        }

        function shoot() {
            const b = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({color: 0x00ffcc}));
            b.position.copy(camera.position);
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
            bullets.push({mesh: b, dir: dir, time: Date.now()});
            scene.add(b);
            gun.position.z += 0.15;
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            if(isPlaying) {
                // AAA Gravity Physics
                velocity.y -= GRAVITY * delta;
                
                const moveSpeed = keys['ShiftLeft'] ? 18.0 : 10.0;
                let direction = new THREE.Vector3();
                if(keys['KeyW']) direction.z -= 1;
                if(keys['KeyS']) direction.z += 1;
                if(keys['KeyA']) direction.x -= 1;
                if(keys['KeyD']) direction.x += 1;
                direction.normalize();
                
                // Momentum movement
                const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
                const sideDir = new THREE.Vector3().crossVectors(camera.up, camDir).normalize();
                
                let moveVec = new THREE.Vector3();
                moveVec.addScaledVector(camDir, -direction.z);
                moveVec.addScaledVector(sideDir, direction.x);
                moveVec.y = 0;
                
                camera.position.addScaledVector(moveVec, moveSpeed * delta);
                camera.position.y += velocity.y * delta;

                // Ground Collision
                if (camera.position.y < 2) {
                    velocity.y = 0;
                    camera.position.y = 2;
                    canJump = true;
                }

                if(keys['Space'] && canJump) {
                    velocity.y += JUMP_FORCE;
                    canJump = false;
                }

                // Object Collision
                collidables.forEach(obj => {
                    if(camera.position.distanceTo(obj.position) < 3) {
                        camera.position.x -= moveVec.x * moveSpeed * delta;
                        camera.position.z -= moveVec.z * moveSpeed * delta;
                    }
                });

                // Weapon Logic
                gun.position.z += ( -0.6 - gun.position.z ) * 0.1;
                
                // Bullet Update
                bullets.forEach((b, i) => {
                    b.mesh.position.addScaledVector(b.dir, 150 * delta);
                    enemies.forEach((en, ei) => {
                        if(b.mesh.position.distanceTo(en.mesh.position) < 2) {
                            scene.remove(en.mesh); enemies.splice(ei, 1);
                        }
                    });
                });

                // Enemy AI Update
                const time = Date.now();
                enemies.forEach(en => {
                    en.mesh.lookAt(camera.position.x, 1.6, camera.position.z);
                    if(en.mesh.position.distanceTo(camera.position) < 60 && time - en.lastShot > 2000) {
                        const eb = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({color: 0xff0000}));
                        eb.position.copy(en.mesh.position);
                        const eDir = new THREE.Vector3().subVectors(camera.position, en.mesh.position).normalize();
                        enemyBullets.push({mesh: eb, dir: eDir});
                        scene.add(eb);
                        en.lastShot = time;
                    }
                });

                enemyBullets.forEach((eb, i) => {
                    eb.mesh.position.addScaledVector(eb.dir, 40 * delta);
                    if(eb.mesh.position.distanceTo(camera.position) < 1.5) {
                        health -= 5;
                        document.getElementById('hp-fill').style.width = health + "%";
                        scene.remove(eb.mesh); enemyBullets.splice(i, 1);
                        if(health <= 0) location.reload();
                    }
                });
            }

            renderer.render(scene, camera);
        }
        window.onload = init;
    </script>
</body>
</html>
