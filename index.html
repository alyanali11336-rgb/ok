<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>VANGUARD | THE HUNTER</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #vignette { position: fixed; inset: 0; box-shadow: inset 0 0 200px #000; pointer-events: none; z-index: 10; }
        #hud { position: absolute; bottom: 30px; left: 30px; z-index: 20; color: #fff; text-shadow: 0 0 10px #000; }
        .stat-bar { width: 300px; height: 10px; background: rgba(255,255,255,0.1); border: 1px solid #ff0000; margin-top: 5px; }
        #hp-fill { width: 100%; height: 100%; background: #ff0000; transition: 0.3s; box-shadow: 0 0 15px #ff0000; }
        #warning { position: absolute; top: 10%; width: 100%; text-align: center; color: #ff0000; font-family: 'Orbitron'; font-size: 2rem; display: none; animation: blink 0.5s infinite; }
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }
        #crosshair { position: fixed; top: 50%; left: 50%; width: 10px; height: 10px; border: 2px solid #fff; transform: translate(-50%, -50%); border-radius: 50%; z-index: 15; }
    </style>
</head>
<body>
    <div id="vignette"></div>
    <div id="crosshair"></div>
    <div id="warning">WARNING: CRITICAL HEALTH - TARGET CHASING</div>
    <div id="hud">
        STATUS: <span id="status-text">OPERATIONAL</span>
        <div class="stat-bar"><div id="hp-fill"></div></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script>
        let scene, camera, renderer, gun, clock;
        let isPlaying = false, health = 100;
        let velocity = new THREE.Vector3();
        let currentEnemy = null; // ONLY ONE ENEMY
        let bullets = [], enemyBullets = [], collidables = [];
        const keys = {};

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a10);
            scene.fog = new THREE.FogExp2(0x0a0a10, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ';

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();

            // Dark Warzone Lighting
            const sun = new THREE.DirectionalLight(0x4444ff, 1);
            sun.position.set(50, 100, 50);
            scene.add(sun, new THREE.AmbientLight(0xffffff, 0.1));

            createWorld();
            spawnTheHunter(); // Spawn the first hunter
            createGun();

            document.body.onclick = () => { if(!isPlaying) document.body.requestPointerLock(); };
            document.addEventListener('pointerlockchange', () => { isPlaying = document.pointerLockElement === document.body; });
            window.onkeydown = (e) => keys[e.code] = true;
            window.onkeyup = (e) => keys[e.code] = false;
            window.onmousemove = (e) => {
                if(isPlaying) {
                    camera.rotation.y -= e.movementX * 0.002;
                    camera.rotation.x -= e.movementY * 0.002;
                    camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
                }
            };
            window.onmousedown = () => { if(isPlaying) shoot(); };

            animate();
        }

        function createGun() {
            gun = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.7), new THREE.MeshStandardMaterial({color: 0x111111}));
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.5), new THREE.MeshStandardMaterial({color: 0x000000}));
            barrel.rotation.x = Math.PI/2; barrel.position.z = -0.5;
            gun.add(body, barrel);
            gun.position.set(0.3, -0.3, -0.6);
            camera.add(gun);
            scene.add(camera);
        }

        function spawnTheHunter() {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({color: 0xff0000, emissive: 0x330000});
            
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.2, 0.4), mat);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshStandardMaterial({color: 0x000000}));
            head.position.y = 0.8;
            
            group.add(torso, head);
            group.position.set(Math.random()*60-30, 1.5, -40);
            scene.add(group);
            currentEnemy = { mesh: group, hp: 150, lastShot: 0 };
        }

        function createWorld() {
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshStandardMaterial({color: 0x111111}));
            floor.rotation.x = -Math.PI/2; floor.receiveShadow = true;
            scene.add(floor);

            // House & Trees
            const wallMat = new THREE.MeshStandardMaterial({color: 0x222222});
            const buildWall = (w, h, d, x, y, z) => {
                const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), wallMat);
                m.position.set(x, y, z); scene.add(m); collidables.push(m);
            };
            buildWall(10, 8, 0.5, 0, 4, -20); buildWall(0.5, 8, 10, -5, 4, -15); buildWall(0.5, 8, 10, 5, 4, -15);

            for(let i=0; i<30; i++) {
                const x = Math.random()*100-50, z = Math.random()*100-50;
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 10), new THREE.MeshStandardMaterial({color: 0x0a0a0a}));
                trunk.position.set(x, 5, z); scene.add(trunk); collidables.push(trunk);
            }
        }

        function shoot() {
            const b = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({color: 0x00ffff}));
            b.position.copy(camera.position);
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
            bullets.push({mesh: b, dir: dir});
            scene.add(b);
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!isPlaying) return;
            const delta = clock.getDelta();
            const time = Date.now();

            // Movement
            const oldPos = camera.position.clone();
            const moveSpeed = 0.12;
            if(keys['KeyW']) camera.translateZ(-moveSpeed);
            if(keys['KeyS']) camera.translateZ(moveSpeed);
            if(keys['KeyA']) camera.translateX(-moveSpeed);
            if(keys['KeyD']) camera.translateX(moveSpeed);

            // Collision
            collidables.forEach(c => { if(camera.position.distanceTo(c.position) < 3) camera.position.copy(oldPos); });
            camera.position.y = 1.8;

            // ENEMY HUNTER LOGIC
            if(currentEnemy) {
                const enemyPos = currentEnemy.mesh.position;
                const dist = enemyPos.distanceTo(camera.position);
                
                // If health is low (< 50), the enemy CHASES you
                if(health < 50) {
                    document.getElementById('warning').style.display = 'block';
                    document.getElementById('status-text').innerText = "CRITICAL - BEING CHASED";
                    const chaseDir = new THREE.Vector3().subVectors(camera.position, enemyPos).normalize();
                    enemyPos.addScaledVector(chaseDir, 0.1); // High speed chase
                } else {
                    document.getElementById('warning').style.display = 'none';
                    document.getElementById('status-text').innerText = "STALKING";
                    enemyPos.addScaledVector(new THREE.Vector3().subVectors(camera.position, enemyPos).normalize(), 0.02); // Slow stalk
                }

                currentEnemy.mesh.lookAt(camera.position.x, 1.5, camera.position.z);

                // Shoot back
                if(dist < 30 && time - currentEnemy.lastShot > 1500) {
                    const eb = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({color: 0xff0000}));
                    eb.position.copy(enemyPos);
                    const eDir = new THREE.Vector3().subVectors(camera.position, enemyPos).normalize();
                    enemyBullets.push({mesh: eb, dir: eDir});
                    scene.add(eb); currentEnemy.lastShot = time;
                }
            }

            // Bullet Collision
            bullets.forEach((b, i) => {
                b.mesh.position.addScaledVector(b.dir, 2);
                if(currentEnemy && b.mesh.position.distanceTo(currentEnemy.mesh.position) < 2) {
                    currentEnemy.hp -= 30;
                    scene.remove(b.mesh); bullets.splice(i, 1);
                    if(currentEnemy.hp <= 0) {
                        scene.remove(currentEnemy.mesh);
                        currentEnemy = null;
                        setTimeout(spawnTheHunter, 3000); // Respawn new hunter after 3s
                    }
                }
            });

            enemyBullets.forEach((eb, i) => {
                eb.mesh.position.addScaledVector(eb.dir, 0.6);
                if(eb.mesh.position.distanceTo(camera.position) < 1.5) {
                    health -= 15;
                    document.getElementById('hp-fill').style.width = health + "%";
                    scene.remove(eb.mesh); enemyBullets.splice(i, 1);
                    if(health <= 0) location.reload();
                }
            });

            renderer.render(scene, camera);
        }
        init();
    </script>
</body>
</html>
