<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Frontline Protocol | Master Build</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* Tactical HUD */
        #hud { position: absolute; bottom: 30px; left: 30px; color: #00ff00; pointer-events: none; z-index: 10; }
        #hp-frame { width: 250px; height: 14px; background: rgba(0,40,0,0.5); border: 2px solid #00ff00; border-radius: 4px; overflow: hidden; }
        #hp-fill { width: 100%; height: 100%; background: #00ff00; transition: width 0.2s ease-out; }
        
        /* Minecraft Style Hotbar */
        #hotbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px; background: rgba(0,0,0,0.8); padding: 8px; border: 2px solid #444; border-radius: 8px;
        }
        .slot {
            width: 50px; height: 50px; border: 2px solid #555; display: flex; 
            flex-direction: column; justify-content: center; align-items: center; 
            color: #777; font-size: 10px; font-weight: bold; border-radius: 4px;
        }
        .slot.active { border-color: #00ff00; color: #fff; background: rgba(0,255,0,0.15); box-shadow: 0 0 10px rgba(0,255,0,0.2); }

        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 18px; height: 18px;
            border: 2px solid #00ff00; border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none; opacity: 0.7;
        }

        #damage-flash { position: absolute; inset: 0; background: red; opacity: 0; pointer-events: none; transition: opacity 0.1s; }
        
        #menu { 
            position: absolute; inset: 0; background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; color: white;
        }
        button { 
            padding: 15px 60px; background: #00ff00; border: none; font-weight: bold; 
            cursor: pointer; color: black; font-size: 1.1em; border-radius: 5px; 
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }
    </style>
</head>
<body>

    <div id="menu">
        <h1 style="letter-spacing: 5px;">FRONTLINE PROTOCOL</h1>
        <p style="color: #888;">[1] RIFLE | [2] TORCH | SHIFT SPRINT</p>
        <button onclick="controls.lock()">DEPLOY AGENT</button>
    </div>

    <div id="damage-flash"></div>
    <div id="crosshair"></div>

    <div id="hud">
        <div style="font-size: 12px; margin-bottom: 5px;">VITAL STATUS: <span id="hp-text">100</span>%</div>
        <div id="hp-frame"><div id="hp-fill"></div></div>
    </div>

    <div id="hotbar">
        <div id="slot-1" class="slot active">1<br>GUN</div>
        <div id="slot-2" class="slot">2<br>TORCH</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- ENGINE CONFIG ---
        let health = 100;
        let activeSlot = 1;
        const enemies = [], medkits = [];
        const input = { w: false, a: false, s: false, d: false, shift: false };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 15, 120);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        window.controls = new PointerLockControls(camera, document.body);

        // --- LIGHTING ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(30, 60, 30);
        sun.castShadow = true;
        scene.add(sun);

        // --- WORLD GENERATION ---
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), new THREE.MeshStandardMaterial({ color: 0x2d4c1e }));
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Checkpoint Assets
        function addObstacle(x, z, w, h, d) {
            const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({color: 0x555555}));
            m.position.set(x, h/2, z);
            scene.add(m);
        }
        addObstacle(0, -10, 6, 1.5, 1); // Front barrier
        addObstacle(10, 10, 2, 8, 2);   // Watchtower base

        // Forest Loop
        for(let i=0; i<80; i++) {
            const tree = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 5), new THREE.MeshStandardMaterial({color: 0x3d2b1f}));
            const leaves = new THREE.Mesh(new THREE.ConeGeometry(2, 6, 6), new THREE.MeshStandardMaterial({color: 0x1a3311}));
            leaves.position.y = 4;
            tree.add(trunk, leaves);
            tree.position.set((Math.random()-0.5)*200, 0, (Math.random()-0.5)*200);
            scene.add(tree);
        }

        // --- ENTITIES ---
        function spawnMedkit(x, z) {
            const kit = new THREE.Group();
            const box = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.4, 0.7), new THREE.MeshStandardMaterial({color: 0xffffff}));
            const red = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.1, 0.1), new THREE.MeshStandardMaterial({color: 0xff0000}));
            red.position.y = 0.21;
            kit.add(box, red);
            kit.position.set(x, 0.2, z);
            scene.add(kit);
            medkits.push(kit);
        }
        spawnMedkit(5, -10); spawnMedkit(-5, 20);

        function spawnEnemy() {
            const group = new THREE.Group();
            const clothes = new THREE.MeshStandardMaterial({color: 0x222222});
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1, 0.3), clothes);
            torso.position.y = 1.1;
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshStandardMaterial({color: 0xffdbac}));
            head.position.y = 1.8;
            group.add(torso, head);
            group.position.set((Math.random()-0.5)*120, 0, (Math.random()-0.5)*120);
            scene.add(group);
            enemies.push(group);
        }
        for(let i=0; i<20; i++) spawnEnemy();

        // --- WEAPON SYSTEM ---
        const gunPivot = new THREE.Group();
        const rifle = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.18, 1.1), new THREE.MeshStandardMaterial({color: 0x050505}));
        rifle.position.set(0.35, -0.4, -0.7);
        const muzzle = new THREE.PointLight(0xffaa00, 0, 6);
        muzzle.position.set(0.35, -0.4, -1.3);
        
        const torch = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.5), new THREE.MeshStandardMaterial({color: 0x222222}));
        torch.rotation.x = Math.PI/2; torch.position.set(0.35, -0.4, -0.4); torch.visible = false;
        const torchL = new THREE.SpotLight(0xffffff, 0, 50, 0.45);
        camera.add(torchL, torchL.target); torchL.target.position.set(0,0,-5);

        gunPivot.add(rifle, muzzle, torch);
        camera.add(gunPivot);
        scene.add(camera);

        // --- INPUT & SWITCHING ---
        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if(k in input) input[k] = true;
            if(e.shiftKey) input.shift = true;
            if(k === '1') setSlot(1);
            if(k === '2') setSlot(2);
        });
        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if(k in input) input[k] = false;
            if(!e.shiftKey) input.shift = false;
        });

        function setSlot(id) {
            activeSlot = id;
            rifle.visible = (id === 1); torch.visible = (id === 2);
            torchL.intensity = (id === 2) ? 120 : 0;
            document.querySelectorAll('.slot').forEach((s, i) => s.className = (i+1 === id) ? 'slot active' : 'slot');
        }

        window.addEventListener('mousedown', () => {
            if(!controls.isLocked || activeSlot !== 1) return;
            muzzle.intensity = 25; rifle.position.z += 0.12;
            setTimeout(() => { muzzle.intensity = 0; rifle.position.z -= 0.12; }, 50);

            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = ray.intersectObjects(enemies, true);
            if(hits.length > 0) {
                let obj = hits[0].object;
                while(obj.parent !== scene) obj = obj.parent;
                scene.remove(obj);
                enemies.splice(enemies.indexOf(obj), 1);
            }
        });

        // --- MAIN GAME LOOP ---
        let prevTime = performance.now();
        function update() {
            requestAnimationFrame(update);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if(controls.isLocked) {
                // Fixed Movement (No Diagonal Speed-Up)
                let moveX = Number(input.d) - Number(input.a);
                let moveZ = Number(input.w) - Number(input.s);
                let currentSpeed = (input.shift ? 15 : 8) * delta;
                
                if(moveX !== 0 || moveZ !== 0) {
                    const norm = Math.sqrt(moveX*moveX + moveZ*moveZ);
                    controls.moveRight((moveX/norm) * currentSpeed);
                    controls.moveForward((moveZ/norm) * currentSpeed);
                    // Sway
                    gunPivot.position.y = Math.sin(time * 0.01) * (input.shift ? 0.05 : 0.02);
                }

                // Enemy Processing
                for(let i = enemies.length - 1; i >= 0; i--) {
                    const en = enemies[i];
                    const d = en.position.distanceTo(camera.position);
                    if(d < 40) {
                        en.lookAt(camera.position.x, 0, camera.position.z);
                        if(d > 2.2) en.translateZ(5 * delta);
                        else {
                            health -= 25 * delta;
                            document.getElementById('hp-fill').style.width = health + "%";
                            document.getElementById('hp-text').innerText = Math.ceil(health);
                            document.getElementById('damage-flash').style.opacity = 0.5;
                            setTimeout(()=>document.getElementById('damage-flash').style.opacity = 0, 50);
                        }
                    }
                }

                // Medkit Pickup
                for(let i = medkits.length - 1; i >= 0; i--) {
                    if(camera.position.distanceTo(medkits[i].position) < 2) {
                        health = Math.min(100, health + 40);
                        document.getElementById('hp-fill').style.width = health + "%";
                        scene.remove(medkits[i]);
                        medkits.splice(i, 1);
                    }
                }

                if(health <= 0) {
                    controls.unlock();
                    location.reload();
                }
            }
            renderer.render(scene, camera);
        }

        update();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
